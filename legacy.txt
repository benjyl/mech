
    # @property
    # def torque(self):
    #     return self.axle_torque / 2

    # def update_wheel_loads(self, normal_aero_load=0):
    #     g = 9.81
    #     self.model_front_wheel.axle_load = (
    #         self.mass
    #         * (
    #             g * self.weight_distribution * self.wheelbase
    #             - self.acceleration * self.centre_height
    #         )
    #         / self.wheelbase
    #     ) + normal_aero_load * self.aero_load_distribution
    #     self.model_rear_wheel.axle_load = (
    #         self.mass * g
    #         + normal_aero_load * (1 - self.aero_load_distribution)
    #         - self.model_front_wheel.axle_load
    #     )

    # @property
    # def total_normal_force(self):
    #     self.tot_normal_force = self.model_front_wheel.axle_load + self.model_rear_wheel.axle_load

    # def update_wheel_torques(self):
    #     av_wheel_ang_speed = self.velocity / self.wheel_radii
    #     motor_speed = av_wheel_ang_speed * self.drive_ratio
    #     motor_torque = min(self.max_torque, self.motor_power / motor_speed)

    #     self.model_front_wheel.axle_torque = 0
    #     self.model_rear_wheel.axle_torque = motor_torque * self.drive_ratio

    # @property
    # def normal_force(self):
    #     return self.axle_load / 2

    # def lateral_force(self, centripetal_force, total_normal_force):
    #     return centripetal_force * self.normal_force / total_normal_force

    # def longitudinal_force(self, centripetal_force, acceleration, total_normal_force):
    #     return (
    #         np.sign(acceleration)
    #         * self.max_longitudinal_force
    #         * (
    #             1
    #             - abs(self.lateral_force(centripetal_force, total_normal_force)) ** 2
    #             / self.max_lateral_force ** 2
    #         )
    #         ** 0.5
    #     )


# # Initialise a car and trackpoints
# car = Car(velocity=0, acceleration=10, centripetal_force=0)
# trackpoints = Trackpoint.from_csv("fixtures/dist.csv", "fixtures/radius.csv")
# time = 0

# trackpoints[0].update(time=0, car=car)

# # need to update acceleration at all points except last so start with first point
# for point, next_point in zip(trackpoints[:-1], trackpoints[1:]):

#     prev_acceleration = 50

#     # tolerance for acceleration
#     while abs((car.acceleration - prev_acceleration) / prev_acceleration) > 0.1:

#         # finding the loads on front and rear axles
#         car.update_wheel_loads()

#         # storing normal forces at front and rear of cars
#         front_normal_force = 2 * car.model_front_wheel.normal_force
#         rear_normal_force = car.model_rear_wheel.normal_force

#         # using method to update total normal force in the car
#         car.total_normal_force

#         # finding max possible lateral forces on both axles
#         front_max_lateral = car.model_front_wheel.max_lateral_force
#         rear_max_lateral = car.model_rear_wheel.max_lateral_force

#         # summing all lateral forces multiply by 2 as 2 wheels at front and rear
#         total_lateral = sum(2 * front_max_lateral, 2 * rear_max_lateral)

#         # finding velocity at all points purely on maximum lateral force and curvature radius
#         centripetal_limited_velocity = abs(
#             np.sqrt(total_lateral * point.curvature_radius / car.mass)
#         )

#         # checking which velocity is lower and storing as car's velocity
#         car.velocity = min(centripetal_limited_velocity, suvat_velocity)

#         # finding car's actual centripetal force
#         car.centripetal_force = (
#             car.mass * car.velocity ** 2
#         ) / point.curvature_radius

#         # finding actual lateral forces at front and rear using lateral force method
#         front_lateral = car.model_front_wheel.lateral_force(
#             car.centripetal_force, car.tot_normal_force
#         )
#         rear_lateral = car.model_rear_wheel.lateral_force(
#             car.centripetal_force, car.tot_normal_force
#         )

#         # finding actual longitudinal forces based on lateral forces
#         front_longitudinal = car.model_front_wheel.longitudinal_force(
#             car.centripetal_force, car.acceleration, car.tot_normal_force
#         )
#         rear_longitudinal = car.model_rear_wheel.longitudinal_force(
#             car.centripetal_force, car.acceleration, car.tot_normal_force
#         )

#         total_longitudinal_force = sum(front_longitudinal, rear_longitudinal)

#         # find wheel torques based on car velocity
#         car.update_wheel_torques

#         # Finding forces at wheels based on max torque
#         wheel_force = car.model_rear_wheel.axle_torque / car.wheel_radii

#         # finding limiting longitudinal force for acceleration
#         total_longitudinal_force = min(total_longitudinal_force, wheel_force)

#         # updating acceleration values
#         prev_acceleration = car.acceleration
#         car.acceleration = total_longitudinal_force / car.mass

#         # Record the telemetry data at this point on the track
#         point.update(time, car)

#         # updating suvat velocity need it for the next trackpoint though not current
#         # not sure how to solve this, potentially make a list of suvat velocities?
#         suvat_velocity = (
#             point.velocity ** 2
#             + 2 * point.acceleration * (next_point.distance - point.distance)
#         ) ** 0.5

#     # update time, need to use the previous and current trackpoints but only zipped current and next
#     # time += 2*
# plot_trackpoints(trackpoints[:200])
# # acceleration <= min(power_acceleration_limit, braking_acceleration_model)
